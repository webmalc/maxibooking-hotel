<?php


use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ODM\MongoDB\DocumentManager;
use MBH\Bundle\BaseBundle\Lib\Test\WebTestCase;
use MBH\Bundle\BaseBundle\Service\Helper;
use MBH\Bundle\HotelBundle\Document\Hotel;
use MBH\Bundle\HotelBundle\Document\RoomType;
use MBH\Bundle\PriceBundle\Document\Tariff;
use MBH\Bundle\SearchBundle\Document\SearchConditions;
use MBH\Bundle\SearchBundle\Services\SearchQueryGenerator;

class SearchQueryGeneratorTest extends WebTestCase
{
    /** @var DocumentManager */
    private $dm;

    public function setUp()
    {
        $this->dm = $this->getContainer()->get('doctrine_mongodb.odm.default_document_manager');
        parent::setUp(); // TODO: Change the autogenerated stub
    }

    public function testGenerate()
    {
        $roomTypes = $this->dm->getRepository(RoomType::class)->findAll();
        $tariffs = $this->dm->getRepository(Tariff::class)->findAll();
        $generator = new SearchQueryGenerator($this->dm);
        $conditions = new SearchConditions();
        $conditions
            ->setBegin(new \DateTime('2018-04-21 midnight'))
            ->setEnd(new \DateTime('2018-04-22 midnight'))
            ->setAdults(3)
            ->setChildren(4)
//            ->setRoomTypes(new ArrayCollection(array_values($roomTypes)))
//            ->setTariffs(new ArrayCollection(array_values($tariffs)))
            ->setAdditionalBegin(1);
        $generator->generate($conditions);

        $this->assertEquals(3, $generator->getQueuesNum());
        $this->assertEquals('this is must be hash', $generator->getSearchQueryHash());
    }

    /**
     * @dataProvider datesProvider
     * @param string $rawDate
     * @param int $range
     * @param int $countExpected
     * @param int $dataExpected
     */
    public function testGetAllDates(string $rawDate, int $range, int $countExpected, array $dataExpected): void
    {
        $date = new \DateTime($rawDate);
        $dm = $this->createMock(DocumentManager::class);
        $generator = new SearchQueryGenerator($dm);

        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'generateDaysWithRange');
        $actual = $method->invokeArgs($generator, [$date, $range]);

        $this->assertCount($countExpected, $actual);
        $this->assertEquals($dataExpected, $actual, 'The array of dates is wrong');

    }

    public function testPrepareConditionsForSearchQueries(): void
    {
        $roomTypes = $this->dm->getRepository(RoomType::class)->findAll();
        $tariffs = $this->dm->getRepository(Tariff::class)->findAll();
        $hotels = $this->dm->getRepository(Hotel::class)->findAll();

        $generator = new SearchQueryGenerator($this->dm);
        $conditions = new SearchConditions();
        $conditions
            ->setBegin(new \DateTime('2018-04-21 midnight'))
            ->setEnd(new \DateTime('2018-04-24 midnight'))
            ->setAdults(3)
            ->setChildren(4)
            ->setRoomTypes(new ArrayCollection(array_values($roomTypes)))
            ->setTariffs(new ArrayCollection(array_values($tariffs)))
            ->setHotels(new ArrayCollection(array_values($hotels)))
            ->setAdditionalBegin(1);

        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'prepareConditionsForSearchQueries');
        $actual = $method->invokeArgs($generator, [$conditions]);


//        $this->assertCount(1, $actual);
//        $this->assertEquals($dataExpected, $actual, 'The array of dates is wrong');

    }

    public function testGetTariffIdsOneTariffNoHotel(): void
    {
        $tariff = $this->dm->getRepository(Tariff::class)->findOneBy([]);

        $generator = new SearchQueryGenerator($this->dm);
        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'getTariffIds');
        $actual = $method->invokeArgs($generator, [new ArrayCollection([$tariff]), [], true]);

        $expected = [
            $tariff->getHotel()->getId() => [
                $tariff->getId(),
            ],
        ];

        $this->assertNotEmpty($actual, 'Result is empty!');
        $this->assertEquals($expected, $actual);
    }

    public function testGetTariffIdsNoTariffNoHotel(): void
    {
        $tariffs = $this->dm->getRepository(Tariff::class)->findAll();
        $generator = new SearchQueryGenerator($this->dm);
        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'getTariffIds');
        $actual = $method->invokeArgs($generator, [new ArrayCollection(), [], false]);

        $expected = [];
        foreach ($tariffs as $tariff) {
            $expected[$tariff->getHotel()->getId()][] = $tariff->getId();
        }

        $this->assertNotEmpty($actual, 'Result is empty!');
        $this->assertEquals($expected, $actual);
    }

    public function testGetTariffIdsOneTariffOneHotel(): void
    {
        $tariff = $this->dm->getRepository(Tariff::class)->findOneBy([]);
        $hotelId = $tariff->getHotel()->getId();
        $strangerHotel = $this->dm->createQueryBuilder(Hotel::class)->field('id')->notEqual($hotelId)->limit(
            1
        )->getQuery()->execute()->toArray();
        $generator = new SearchQueryGenerator($this->dm);
        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'getTariffIds');
        $actual = $method->invokeArgs(
            $generator,
            [new ArrayCollection([$tariff]), [array_values($strangerHotel)], false]
        );
        $expected = [
            $tariff->getHotel()->getId() => [
                $tariff->getId(),
            ],
        ];
        $this->assertNotEmpty($actual, 'Result is empty!');
        $this->assertEquals($expected, $actual);

    }

    public function testGetTariffIdsNoTariffOneHotel(): void
    {
        $hotel = $this->dm->getRepository(Hotel::class)->findOneBy([]);
        $tariffs = $this->dm->createQueryBuilder(Tariff::class)->field('hotel.id')->equals($hotel->getId())->getQuery(
        )->execute()->toArray();
        $generator = new SearchQueryGenerator($this->dm);
        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'getTariffIds');
        $actual = $method->invokeArgs($generator, [new ArrayCollection([]), [$hotel->getId()], false]);

        foreach ($tariffs as $tariff) {
            $expected[$hotel->getId()][] = $tariff->getId();
        }

        $this->assertNotEmpty($actual, 'Result is empty!');
        $this->assertEquals($expected, $actual);
    }


    public function testGetRoomTypeIdsOneRoomTypeNoHotel(): void
    {
        $roomType = $this->dm->getRepository(RoomType::class)->findOneBy([]);
        $generator = new SearchQueryGenerator($this->dm);
        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'getRoomTypeIds');
        $actual = $method->invokeArgs($generator, [new ArrayCollection([$roomType]), []]);
        $expected = [
            $roomType->getHotel()->getId() => [
                $roomType->getId(),
            ],
        ];

        $this->assertNotEmpty($actual, 'Result is empty!');
        $this->assertEquals($expected, $actual);
    }

    public function testGetRoomTypeIdsOneRoomTypeOneHotel(): void
    {
        $roomType = $this->dm->getRepository(RoomType::class)->findOneBy([]);
        $hotel = $this->dm->createQueryBuilder(Hotel::class)->field('id')->notEqual(
            $roomType->getHotel()->getId()
        )->getQuery()->execute()->toArray();
        $hotelIds = Helper::toIds($hotel);
        $generator = new SearchQueryGenerator($this->dm);
        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'getRoomTypeIds');
        $actual = $method->invokeArgs($generator, [new ArrayCollection([$roomType]), [$hotelIds]]);
        $expected = [
            $roomType->getHotel()->getId() => [
                $roomType->getId(),
            ],
        ];
        $this->assertNotEmpty($actual, 'Result is empty!');
        $this->assertEquals($expected, $actual);
    }

    public function testGetRoomTypeIdsNoRoomTypeNoHotel(): void
    {
        $roomTypes = $this->dm->getRepository(RoomType::class)->findAll();
        $generator = new SearchQueryGenerator($this->dm);
        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'getRoomTypeIds');
        $actual = $method->invokeArgs($generator, [new ArrayCollection(), []]);
        $expected = [];
        foreach ($roomTypes as $roomType) {
            $expected[$roomType->getHotel()->getId()][] = $roomType->getId();
        }

        $this->assertNotEmpty($actual, 'Result is empty!');
        $this->assertEquals($expected, $actual);
    }

    public function testGetRoomTypeIdsNoRoomTypeOneHotel(): void
    {
        $hotel = $this->dm->getRepository(Hotel::class)->findOneBy([]);
        $roomTypes = $this->dm->createQueryBuilder(RoomType::class)->field('hotel.id')->equals(
            $hotel->getId()
        )->getQuery()->execute()->toArray();
        $generator = new SearchQueryGenerator($this->dm);
        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'getRoomTypeIds');
        $actual = $method->invokeArgs($generator, [new ArrayCollection(), [$hotel->getId()]]);
        $expected = [];
        foreach ($roomTypes as $roomType) {
            $expected[$hotel->getId()][] = $roomType->getId();
        }

        $this->assertNotEmpty($actual, 'Result is empty!');
        $this->assertEquals($expected, $actual);
    }

    public function testGetRoomTypeIdsNoRoomTypeTwoHotel(): void
    {
        $hotels = $this->dm->getRepository(Hotel::class)->findAll();
        $hotelsIds = Helper::toIds($hotels);
        $roomTypes = $this->dm->createQueryBuilder(RoomType::class)->field('hotel.id')->in($hotelsIds)->getQuery(
        )->execute()->toArray();
        $generator = new SearchQueryGenerator($this->dm);
        $method = $this->getPrivateMethod(SearchQueryGenerator::class, 'getRoomTypeIds');
        $actual = $method->invokeArgs($generator, [new ArrayCollection(), $hotelsIds]);
        $expected = [];
        foreach ($roomTypes as $roomType) {
            $expected[$roomType->getHotel->getId()][] = $roomType->getId();
        }

        $this->assertNotEmpty($actual, 'Result is empty!');
        $this->assertEquals($expected, $actual);
    }

    private function getPrivateMethod($className, $methodName)
    {
        $reflector = new ReflectionClass($className);
        $method = $reflector->getMethod($methodName);
        $method->setAccessible(true);

        return $method;
    }

    public function datesProvider()
    {
        return [
            [
                '21.04.2018 midnight',
                1,
                3,
                [
                    new \DateTime('20.04.2018 midnight'),
                    new \DateTime('21.04.2018 midnight'),
                    new \DateTime('22.04.2018 midnight'),
                ],
            ],
            [
                '05.06.2018 midnight',
                0,
                1,
                [
                    new \DateTime('05.06.2018 midnight'),
                ],
            ],
            [
                '22.04.2018 midnight',
                2,
                5,
                [
                    new \DateTime('20.04.2018 midnight'),
                    new \DateTime('21.04.2018 midnight'),
                    new \DateTime('22.04.2018 midnight'),
                    new \DateTime('23.04.2018 midnight'),
                    new \DateTime('24.04.2018 midnight'),
                ],
            ],
            [
                '30.04.2018 midnight',
                3,
                7,
                [
                    new \DateTime('27.04.2018 midnight'),
                    new \DateTime('28.04.2018 midnight'),
                    new \DateTime('29.04.2018 midnight'),
                    new \DateTime('30.04.2018 midnight'),
                    new \DateTime('01.05.2018 midnight'),
                    new \DateTime('02.05.2018 midnight'),
                    new \DateTime('03.05.2018 midnight'),
                ],
            ],
        ];
    }
}